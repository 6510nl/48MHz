//-----------------------------------------------------------
// Variables
//-----------------------------------------------------------

.var music = LoadSid("SID/Airwolf.sid")

//-----------------------------------------------------------
// Macros
//-----------------------------------------------------------

.macro SetBorderColor(color)
{
lda #color
sta $d020
}


//-----------------------------------------------------------
// Basic start line
//-----------------------------------------------------------

.pc = $0801	"Basic Start"
:BasicUpstart($6510)

//-----------------------------------------------------------
// Start of main program
//-----------------------------------------------------------
.pc = $6510	"Main Program"

lda music.startSong
jsr music.init 


ldx #$00
!:	lda #$20
	sta $0400,X
	sta $0500,X
	sta $0600,X
	sta $0700,X
	inx
bne !-	


sei				//	disable maskable IRQs

lda #$7f
sta $dc0d		//	disable timer interrupts which can be generated by the two CIA chips
sta $dd0d		//	the kernal uses such an interrupt to flash the cursor and scan the keyboard, so we better stop it.

lda $dc0d		//	by reading this two registers we negate any pending CIA irqs.
lda $dd0d		//	if we don't do this, a pending CIA irq might occur after we finish setting up our irq. we don't want that to happen.

lda #$01		//	this is how to tell the VICII to generate a raster interrupt
sta $d01a

lda #$00		//	this is how to tell at which rasterline we want the irq to be triggered
sta $d012

lda #$00 		//#%00111011	//	 #$1b - as there are more than 256 rasterlines, the topmost bit of $d011 serves as
sta $d011  		//	the 8th bit for the rasterline we want our irq to be triggered.
				//	here we simply set up a character screen, leaving the topmost bit 0.

lda #$35		//	we turn off the BASIC and KERNAL rom here
sta $01			//	the cpu now sees RAM everywhere except at $d000-$e000, where still the registers of
				//	SID/VICII/etc are visible

lda #<irq 		//	this is how we set up
sta $fffe		//	the address of our interrupt code
lda #>irq
sta $ffff

cli	//	enable maskable interrupts again

start:
jmp start	//	we better don't RTS, the ROMS are now switched off, there's no way back to the system

irq:

//	Being all kernal irq handlers switched off we have to do more work by ourselves.
//	When an interrupt happens the CPU will stop what its doing, store the status and return address
//	into the stack, and then jump to the interrupt routine. It will not store other registers, and if
//	we destroy the value of A/X/Y in the interrupt routine, then when returning from the interrupt to
//	what the CPU was doing will lead to unpredictable results (most probably a crash). So we better
//	store those registers, and restore their original value before reentering the code the CPU was
//	interrupted running.
//	
//	If you won't change the value of a register you are safe to not to store / restore its value.
//	However, it's easy to screw up code like that with later modifying it to use another register too
//	and forgetting about storing its state.
//	
//	The method shown here to store the registers is the most orthodox and most failsafe.

pha					//	store register A in stack
txa					//	
pha					//	store register X in stack
tya 				//	
pha 				//	store register Y in stack

!:	lda $d012
	cmp #$42
	bne	!-
	ldx #$00
!:	inx
	cpx #$4b
	bne !-
jsr raster42

!:	lda $d012
	cmp #$43
	bne	!-
	ldx #$00
!:	inx
	cpx #$4c
	bne !-
jsr raster43

!:	lda $d012
	cmp #$44
	bne	!-
	ldx #$00
!:	inx
	cpx #$4b
	bne !-
jsr raster44

!:	lda $d012
	cmp #$45
	bne	!-
	ldx #$00
!:	inx
	cpx #$4b
	bne !-
	nop
	nop
jsr raster45

!:	lda $d012
	cmp #$46
	bne	!-
	ldx #$00
!:	inx
	cpx #$4b
	bne !-
jsr raster46

!:	lda $d012
	cmp #$47
	bne	!-
	ldx #$00
!:	inx
	cpx #$4b
	bne !-
jsr raster47

!:	lda $d012
	cmp #$48
	bne	!-
	ldx #$00
!:	inx
	cpx #$4a
	bne !-
	nop
jsr raster48

!:	lda $d012
	cmp #$f2
	bne	!-

:SetBorderColor(14)
jsr music.play
:SetBorderColor(0)



lda #$ff	//	;this is the orthodox and safe way of clearing the interrupt condition of the 
sta $d019	//	;if you don't do this the interrupt condition will be present all the time an
	//	;up having the CPU running the interrupt code all the time, as when it exists 
	//	;interrupt, the interrupt request from the VICII will be there again regardles
	//	;rasterline counter.
	//
	//	;it's pretty safe to use inc $d019 (or any other rmw instruction) for brevity,
	//	;will only fail on hardware like c65 or supercpu. c64dtv is ok with this thoug

pla
tay	//	;restore register Y from stack (remember stack is FIFO: First In First Out)
pla	//	
tax	//	;restore register X from stack
pla	//	;restore register A from stack
rti	//	;Return From Interrupt, this will load into the Program Counter register the a
	//	;where the CPU was when the interrupt condition arised which will make the CPU
	//	;the code it was interrupted at also restores the status register of the CPU

//-----------------------------------------------------------

raster42:
	ldx #$00
	!:
		lda row42,x 
		sta $d020
		sta $d021
		inx
		cpx #120
	bne !-
rts

raster43:
	ldx #$00
	!:
		lda row43,x 
		sta $d020
		sta $d021
		inx
		cpx #120
	bne !-
rts

raster44:
	ldx #$00
	!:
		lda row44,x 
		sta $d020
		sta $d021
		inx
		cpx #120
	bne !-
rts

raster45:
	ldx #$00
	!:
		lda row45,x 
		sta $d020
		sta $d021
		inx
		cpx #120
	bne !-
rts

raster46:
	ldx #$00
	!:
		lda row46,x 
		sta $d020
		sta $d021
		inx
		cpx #120
	bne !-
rts

raster47:
	ldx #$00
	!:
		lda row47,x 
		sta $d020
		sta $d021
		inx
		cpx #120
	bne !-
rts

raster48:
	ldx #$00
	!:
		lda row48,x 
		sta $d020
		sta $d021
		inx
		cpx #120
	bne !-
rts

//-----------------------------------------------------------
	
.pc = $6000
row42:
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 0,1,0,1,0,1,0,1
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0



.pc = $6100
row43: 
.byte 11,12,15,1,15,12,11,0
.byte 6,14,15,1,15,14,6,0
.byte 0,1,0,1,0,1,0,1
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0

row44: 
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 0,1,0,1,0,1,0,1
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
row45: 
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 0,1,0,1,0,1,0,1
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
row46: 
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
row47: 
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
row48: 
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
.byte 6,14,15,1,15,14,6,0
//-----------------------------------------------------------
.pc = music.location "SID"
.fill	music.size, music.getData(i)
.print	""
.print	"SID Data"
.print	"--------"
.print	"location=$"+toHexString(music.location)
.print	"init=$"+toHexString(music.init)
.print	"play=$"+toHexString(music.play)
//-----------------------------------------------------------
